What students should learn (say this out loud)
  1) GitRepository = “Flux, watch this repo”
  2) Kustomization = “Apply this folder continuously”
  3) prune=true = “If it’s removed from Git, remove it from cluster”
  4) Flux is a reconciler: cluster drift gets corrected back to Git state




“Day 1 Flux → Splunk” lab with:

1) install Flux controllers
2) create GitHub GitRepository source
3) create Kustomization pointing to clusters/dev/splunk
4) a minimal Splunk skeleton (namespace + service + statefulset placeholder) so students see it reconcile

I’ll assume:
  branch = main
  repo path = clusters/dev/splunk
  namespace = splunk-dev

Part 1 — Install Flux (cluster side)

kubectl apply -f https://github.com/fluxcd/flux2/releases/latest/download/install.yaml
kubectl -n flux-system get pods

Expected: flux controllers running in flux-system.

Part 2 — Connect Flux to your public GitHub repo
01-gitrepository.yaml

Apply
kubectl apply -f 01-gitrepository.yaml

Verify source:
flux get sources git -A
kubectl -n flux-system describe gitrepository github-platform

Part 3 — Tell Flux what folder to apply (Splunk folder)
02-kustomization-splunk-dev.yaml

Apply:
kubectl apply -f 02-kustomization-splunk-dev.yaml

Check:
flux get kustomizations -A
kubectl -n flux-system describe kustomization splunk-dev

Error Message: If the folder doesn’t exist yet, Flux will report an error — that’s normal until you push the repo structure.

Part 4 — Create the Git repo structure + minimal Splunk manifests

In your GitHub repo, add:

1) clusters/dev/splunk/kustomization.yaml
2) clusters/dev/splunk/namespace.yaml
3) clusters/dev/splunk/service.yaml

(Expose Splunk Web or mgmt via ClusterIP as a demo. Port here is your choice; you can change later.)

Commit + push:

git add clusters/dev/splunk
git commit -m "Add Flux-managed splunk-dev skeleton"
git push


Part 5 — Force reconciliation (optional “make it happen now”)
flux reconcile source git github-platform -n flux-system
flux reconcile kustomization splunk-dev -n flux-system --with-source

Verify:
kubectl get ns | grep splunk-dev
kubectl -n splunk-dev get pods,svc

Debug section (required for the exam)
If Flux can’t fetch GitHub

kubectl -n flux-system logs deploy/source-controller --tail=200
kubectl -n flux-system describe gitrepository github-platform

If Flux fetches but won’t apply
kubectl -n flux-system logs deploy/kustomize-controller --tail=200
kubectl -n flux-system describe kustomization splunk-dev



If you added PVC, Secret, can Config later

Commit + push (Flux will deploy)
git add clusters/dev/splunk
git commit -m "Deploy Splunk dev (PVC + secret + config) via Flux"
git push

Force reconcile (optional):
flux reconcile source git github-platform -n flux-system
flux reconcile kustomization splunk-dev -n flux-system --with-source

Verify + access Splunk Web UI
check
kubectl -n splunk-dev get pods
kubectl -n splunk-dev get pvc
kubectl -n splunk-dev describe pod splunk-0

Port-forward:
kubectl -n splunk-dev port-forward svc/splunk 8091:8091

Open:
http://localhost:8091

Login:
user: admin
password: from SPLUNK_PASSWORD

Troubleshooting

PVC Pending
kubectl -n splunk-dev describe pvc splunk-pvc
kubectl get storageclass

ImagePullBackOff (Docker Hub throttling / blocked)
kubectl -n splunk-dev describe pod splunk-

Splunk won’t start (license/env)---> Did you pay rent?
kubectl -n splunk-dev logs splunk-0

How to add Ingress + TLS

You’ll add 3 things to your repo:

  1) Ingress-NGINX controller (cluster add-on, one-time install)
  2) cert-manager (cluster add-on, one-time install)
  3) App manifests: ClusterIssuer + Ingress for Splunk (in your clusters/dev/splunk/ folder)

I’ll give you both TLS modes:

  A) Self-signed TLS (works anywhere, perfect for labs)
  B) Let’s Encrypt HTTP-01 (requires real DNS + public ingress)

Install Ingress-NGINX (one-time, cluster)
Apply official manifest (simple)

kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml

Verify:
kubectl -n ingress-nginx get pods
kubectl -n ingress-nginx get svc

You should see a LoadBalancer service (cloud) or NodePort (depends on environment).

Install cert-manager (one-time, cluster)
Apply cert-manager manifest (includes CRDs)

kubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.yaml

Verify:
kubectl -n cert-manager get pods
kubectl get crd | grep cert-manager

Add TLS for Splunk (in Git repo)
Add these files under:
clusters/dev/splunk/
Update your kustomization.yaml to include them.

clusters/dev/splunk/kustomization.yaml


Lab mode (recommended first): Self-signed TLS
issuer.yaml (SelfSigned ClusterIssuer)

ingress.yaml (TLS enabled)
Replace splunk-dev.example.com with your domain (or a fake domain for local testing).

What happens:

cert-manager generates a self-signed cert

stores it in Secret splunk-web-tls

NGINX terminates TLS and forwards to Splunk service

✅ Works even with no public DNS.
(You may need to add an /etc/hosts entry to test locally.)

B) Real-world mode: Let’s Encrypt (HTTP-01)

Use this only if:
  your Ingress gets a public IP/hostname
  DNS for your host points to it
  port 80/443 are reachable from the internet

public_ip_issuer.yaml (Let’s Encrypt staging — recommended first)
public_ip_ingress.yaml (Let’s Encrypt TLS)

Once staging works, swap to production issuer:
Production issuer (same but different server URL)


